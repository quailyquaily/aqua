# 2026-02-24 Group E2EE Design (MVP Draft)

Status: Draft  
Owner: aqua core/protocol  
Scope: `aqua/*`, `cmd/aqua/*`, docs

## Objective

Add practical group end-to-end encryption (E2EE) to Aqua without breaking current 1:1 flows.

The MVP must be:

- decentralized (no mandatory central server)
- relay-compatible (direct/relay transport unchanged)
- incrementally implementable on current codebase
- consent-gated (invitee must explicitly accept before becoming a member)

## First-Principles Constraints

1. Aqua transport today is peer-to-peer RPC over libp2p.
2. Relay is forwarding only (no durable mailbox).
3. Current delivery semantics are best-effort online delivery.
4. Backward compatibility for 1:1 CLI and protocol should be preserved.
5. Implementation complexity must stay below MLS-level complexity for first release.
6. Prefer reusing existing operations over adding new command surfaces.

## Non-Goals (MVP)

1. MLS (RFC 9420) full implementation.
2. Exactly-once delivery.
3. Offline guaranteed delivery by itself.
4. Perfect metadata privacy (peer IDs and routing are still visible at transport level).
5. Group profile metadata (`name`, `topic`, `avatar`, announcement).
6. Advanced governance (freeze/archive/dissolve/owner transfer/multi-sig).

## Threat Model

Protect against:

- relay/operator/network observer reading message content
- unauthorized non-members decrypting group messages
- removed members reading new-epoch messages
- silent forced enrollment without invitee acceptance

Out of scope:

- compromised endpoint devices
- traffic analysis resistance

## Design Choice

Use Sender Keys + Epoch Rotation, not MLS for MVP.

Rationale:

- O(1) ciphertext per group message
- low integration cost with existing `agent.data.push`
- straightforward member add/remove handling through epoch changes

MLS remains a future upgrade path if stronger formal guarantees are required.

## Group Model

Each group has:

- `group_id` (stable)
- `epoch` (monotonic integer, starts at 1)
- `roles`: `manager`, `member`
- `manager_peer_ids` (non-empty set in MVP)
- `max_members = 256` (includes managers)

Default:

- creator is `manager`
- manager may invite/remove members
- manager may promote/demote `manager` role

Key points:

- invitee is not a member until explicit accept
- message decryption must not depend on creator being online
- role updates do not change epoch
- at least one manager must always exist (demoting the last manager is invalid)
- membership growth beyond `max_members` is invalid

## Crypto Model (MVP)

### Identity and Key Material

- Keep existing ed25519 identity key for signatures and identity binding.
- Add x25519 keypair per node for E2EE key wrapping.
- Use ChaCha20-Poly1305 as the MVP AEAD.

### Sender Keys

For each `(group_id, epoch, sender_peer_id)`:

- one sender chain key
- per-message key derived by hash ratchet + counter

### Replay Protection Window

- maintain per-sender sliding counter window size `64`
- accept unseen counters within window; reject duplicates and too-old counters

### Membership Change

On `invite.accept` that is committed by manager, or on member removal:

1. `epoch += 1`
2. all active senders rotate sender keys for the new epoch
3. distribute new sender keys only to valid members in the new epoch

On `invite.reject`:

- no epoch change
- no sender key rotation

Epoch increment rules (strict):

- `epoch += 1` only when a valid pending invite is accepted and committed into membership
- `epoch += 1` only when removing a currently active member
- all other control messages MUST NOT change epoch

Removed members cannot decrypt new epoch messages.

## Message Types

MVP introduces two logical message classes over existing transport:

1. Group control messages
2. Group data messages

Both are carried via existing `agent.data.push` with new topics.

### Suggested Topics

- `group.control.v1`
- `group.message.v1`

### Group Data Envelope (logical)

```json
{
  "version": 1,
  "group_id": "grp_...",
  "epoch": 3,
  "sender_peer_id": "12D3KooW...",
  "sender_key_id": "sk_...",
  "counter": 42,
  "content_type": "text/plain",
  "ciphertext_base64": "...",
  "nonce_base64": "...",
  "aad_hash": "...",
  "sig_base64": "..."
}
```

AAD should bind at least:

- `group_id`
- `epoch`
- `sender_peer_id`
- `sender_key_id`
- `counter`
- `content_type`

### Group Control Messages (logical)

- `group.create`
- `group.invite`
- `group.invite.accept`
- `group.invite.reject`
- `group.members.update`
- `group.role.update`
- `group.sender_key.update`

Control messages must be signed and authorization-checked:

- `group.invite` / `group.members.update` / `group.role.update` / `group.sender_key.update`: manager signature required
- `group.invite.accept` / `group.invite.reject`: invitee signature required

`group.role.update` conflict handling (MVP):

- each role update carries `base_role_version`
- receiver applies only when `base_role_version == current_role_version`
- on apply: `role_version += 1`; on mismatch: reject and require sender retry with fresh state

### Invite Flow (MVP)

1. Manager creates `invite_id` (128-bit CSPRNG random) and sends signed `group.invite`.
2. `group.invite` must bind at least: `group_id`, `invite_id`, `inviter_peer_id`, `invitee_peer_id`, `created_at`, `expires_at`.
3. Invite expiry is fixed to 7 days (`expires_at = created_at + 7d`).
4. Expiry validation allows clock skew tolerance `+-300s`.
5. Invitee runs `accept` or `reject`.
6. Invitee emits signed `group.invite.accept` or `group.invite.reject` referencing exact `group_id + invite_id`.
7. Manager validates response. If accepted and invite is still pending+unexpired and active members are below `max_members`, manager commits `group.members.update` (`epoch += 1`) and distributes rotated sender keys.

Idempotency and replay handling:

- invite uniqueness scope is `(group_id, invite_id)`
- first terminal response wins (`accepted` or `rejected`)
- duplicate terminal responses are no-op and logged
- responses for expired/nonexistent invites are rejected and logged

## Storage Model

Add local persistent files (names tentative):

- `groups.json` (group metadata + `manager_peer_ids` + local role)
- `group_roles.json` (manager/member assignments + `role_version`)
- `group_members.json` (current epoch membership snapshot + per-member `last_seen_at`)
- `group_invites.json` (pending/accepted/rejected invite records)
- `group_sender_keys.json` (sender key states per epoch)
- `group_counters.json` (last seen sender counters)

These are independent from inbox/outbox files and should use resource-split fs locks.

## Receive Rules

On inbound group control message:

1. verify signature and authorization
2. for `group.invite`, ensure local peer is the invitee before storing pending invite
3. for `group.invite.accept`, manager validates pending invite before committing membership update
4. for `group.role.update`, reject any transition that would leave zero managers
5. for `group.role.update`, enforce `base_role_version` precondition
6. for member add on accepted invite, reject if active members already reach `max_members`
7. log explicit reject reasons for invalid/unauthorized control messages

On any valid inbound message/control from peer `P`:

- update `last_seen_at` for `P` with local observed timestamp

On inbound `group.message.v1`:

1. verify local membership is active in referenced `group_id` + `epoch`
2. verify signature/identity binding
3. enforce per-sender replay window (`64`)
4. decrypt
5. store into inbox with group metadata

Rejected messages should be logged with explicit reason.

## Send Rules

On outbound group data message:

1. verify local membership and current epoch state
2. derive next sender message key (ratchet)
3. encrypt payload
4. dispatch to each reachable member peer

On outbound control operations:

- `invite`, `remove-member`, and `role` are manager-only
- `invite accept/reject` are invitee-only and reference a concrete pending invite
- `remove-member` may target a manager only if resulting manager set remains non-empty

MVP keeps current online-delivery behavior:

- only online/reachable peers receive immediately
- offline catch-up requires future durable retransmission queue

## CLI Impact (Planned)

Keep existing 1:1 commands unchanged.

Add group commands:

- `aqua group create`
- `aqua group invite <group_id> <peer_id>`
- `aqua group invite accept <group_id> <invite_id>`
- `aqua group invite reject <group_id> <invite_id>`
- `aqua group remove-member <group_id> <peer_id>`
- `aqua group role <group_id> <peer_id> <manager|member>`
- `aqua group list`
- `aqua group show <group_id>`
- `aqua group send <group_id> <message>`

Notes:

- MVP does not add group profile commands (`rename`, `topic`, `avatar`).
- MVP keeps governance minimal: only `group role` (manager/member) is supported.
- MVP does not add other governance commands (`freeze`, `archive`, `dissolve`, owner transfer, multi-sig).
- `group show` should include member-level `last_seen_at` to support manager removal decisions for stale members.

Extend inbox/outbox filters:

- `--group <group_id>`
- output fields: `scope`, `group_id`, `sender_peer_id`, `epoch`

## Security Properties (MVP Target)

1. Confidentiality against relay/network observer.
2. Forward secrecy per sender chain progression.
3. Post-removal secrecy after epoch rotation.
4. Sender authenticity tied to Aqua identity.
5. Consent-gated membership (invite accept required before membership activation).

## Operational Notes

1. Relay mode does not change crypto behavior.
2. Relay restart can still cause temporary reachability impact.
3. Group cryptography and transport reachability are orthogonal concerns.
4. Managers can be multiple; this reduces single-point failure for membership management.
5. If all managers are permanently unavailable, membership management halts; practical recovery is creating a new group.
6. Demoting/removing the last manager is invalid and must be rejected.
7. Offline members do not block epoch progression.
8. No automatic stale-member removal in MVP; manager removes manually based on observed `last_seen_at`.
9. Maximum active members per group is `256`; add attempts beyond this limit are rejected.

## Rollout Plan

Phase 1: Data model and invite control-plane scaffolding

- group metadata storage + `manager_peer_ids`
- invite state storage (`pending` / `accepted` / `rejected`)
- control message validation/authorization
- role update validation (`manager`/`member`, non-empty manager set invariant)

Phase 2: Sender keys and encrypted group payload

- sender key distribution
- group message encryption/decryption
- epoch rotation on invite-accept and remove-member
- inbox/outbox group fields

Phase 3: CLI + observability

- command set (`create`, `invite`, `invite accept/reject`, `remove-member`, `role`, `list`, `show`, `send`)
- structured logs for invite/control/data paths
- tests for invite lifecycle, member add/remove, role promotion/demotion, and epoch rotation

Phase 4: Delivery reliability integration

- integrate with durable retransmission queue (future roadmap item)

## Open Questions

1. Whether manager role updates should stay single-signature in v1 or evolve to threshold approvals in v2.
